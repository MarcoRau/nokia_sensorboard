/*

	Demo of glcd library with AVR8 microcontroller
	
	Tested on a custom made PCB (intended for another project)

	See ../README.md for connection details

*/

#include <avr/io.h>
#include "glcd/glcd.h"
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include "glcd/fonts/Liberation_Sans15x21_Numbers.h"
#include "glcd/fonts/font5x7.h"
#include <avr/pgmspace.h>
#define F_CPU 16000000UL  // 1 MHz

// EEPROM
#define ERROR		1
#define SUCCESS		0
#define EEWRITE		0b10100000
#define EEREAD		0b10100001

/* Function prototypes */
static void setup(void);

static void setup(void)
{
	/* Set up glcd, also sets up SPI and relevent GPIO pins */
	glcd_init();
}

uint8_t ms, ms10,ms100,sec,min,entprell, state;

ISR (TIMER1_COMPA_vect)
{
	ms10++;
	
	if(entprell != 0){
		entprell--;
	}
	
	//10ms
	if(ms10 == 10){
		ms10 = 0;
		ms100++;
	}
	
	//100ms
    if(ms100 == 10){
		ms100 = 0;
		sec++;
	}
	
	//Minute
	if(sec == 10){
		sec = 0;
		min++;
		if(state == 11){
			state = 10;
		}
	}
}
// EEPROM-------------------------------------------------------------------------

void TWIInit( void ){
	// set SCL to 400kHz
	TWSR = 0x00;
	TWBR = 0x0C;
	// enable TWI
	TWCR = ( 1 << TWEN );
}

void TWIStart ( void ){
	TWCR = ( 1 << TWINT ) | ( 1 << TWSTA ) | ( 1 << TWEN );
	while (( TWCR & ( 1 << TWINT )) == 0 );
}

void TWIStop ( void ){
	TWCR = ( 1 << TWINT ) | ( 1 << TWSTO ) | ( 1 << TWEN );
}

void TWIWrite ( uint8_t u8data ){
	TWDR = u8data;
	TWCR = ( 1 << TWINT ) | ( 1 << TWEN );
	while (( TWCR & ( 1 << TWINT )) == 0 );
}

uint8_t TWIReadACK ( void ){
	TWCR = ( 1 << TWINT ) | ( 1 << TWEN )|( 1 << TWEA );
	while (( TWCR & ( 1 << TWINT )) == 0 );
	return TWDR;
}
// read byte with NACK
uint8_t TWIReadNACK ( void ){
	TWCR = ( 1 << TWINT ) | ( 1 << TWEN );
	while (( TWCR & ( 1 << TWINT )) == 0 );
	return TWDR;
}

uint8_t TWIGetStatus( void ){
	uint8_t status;
	// mask status
	status = TWSR & 0xF8;
	return status;
}

uint8_t EEWriteByte ( uint16_t u16addr, uint8_t u8data ){
	uint8_t addr_l, addr_h;
	addr_l = u16addr;
	addr_h = (u16addr>>8);
	
    TWIStart();
    if ( TWIGetStatus() != 0x08 )
        return ERROR;
	TWIWrite(EEWRITE);
    if ( TWIGetStatus() != 0x18 )
        return ERROR;   
	TWIWrite(addr_l);
	if ( TWIGetStatus() != 0x28 )
        return ERROR;
	TWIWrite(addr_h);
	if ( TWIGetStatus() != 0x28 )
        return ERROR;
	TWIWrite(u8data);
	if ( TWIGetStatus() != 0x28 )
        return ERROR;
	TWIStop();
    return SUCCESS;
}


uint8_t EEReadByte ( uint16_t u16addr ){
	uint8_t addr_l, addr_h;
	addr_l = u16addr;
	addr_h = (u16addr>>8);
	uint8_t u8data = 0;
	
    //uint8_t databyte;
    TWIStart();
    if ( TWIGetStatus() != 0x08 )
        return 2;
	TWIWrite(EEWRITE);
	if ( TWIGetStatus() != 0x18 )
        return 5;
	TWIWrite(addr_l);
	if ( TWIGetStatus() != 0x28 )
        return 5;
	TWIWrite(addr_h);
	if ( TWIGetStatus() != 0x28 )
        return 5;
    TWIStart();
    if ( TWIGetStatus() != 0x10 )
        return 5;
	TWIWrite(EEREAD);
	if ( TWIGetStatus() != 0x40 )
        return 5;
	u8data = TWIReadNACK();
    if ( TWIGetStatus() != 0x58 )
        return 7;
    TWIStop();
	
    return u8data;
}


/* NOCH NICHT!!!

uint8_t EEWritePeage ( uint8_t page, uint8_t *u8data ){
	// calculate page address
	uint8_t u8paddr = 0;
	uint8_t i;
	u8paddr = page << 4;
	TWIStart();
	if ( TWIGetStatus() != 0x08 )
		return ERROR;
	// select page start address and send A2 A1 A0 bits send write command
	TWIWrite ((( EEWRITE ) | ( u8paddr >> 3 )) & ( ~1 ));
	if ( TWIGetStatus() != 0x18 )
		return ERROR;
	// send the rest of address
	if ( TWIGetStatus() != 0x28 )
		return ERROR;
	// write page to eeprom
	for ( i = 0; i < 16; i++ ){
		TWIWrite ( *u8data++ );
			if ( TWIGetStatus() != 0x28 )
				return ERROR;
	}
	TWIStop();
	return SUCCESS;
}

uint8_t EEReadPage ( uint8_t page, uint8_t *u8data ){
	// calculate page address
	uint8_t u8paddr = 0;
	uint8_t i;
	u8paddr = page << 4;
	TWIStart();
	if ( TWIGetStatus() != 0x08 )
		return ERROR;
	// select page start address and send A2 A1 A0 bits send write command
	TWIWrite ((( EEREAD ) | ( u8paddr >> 3 )) & ( ~1 ));
	if ( TWIGetStatus() != 0x18 )
		return ERROR;
	// send the rest of address
	TWIWrite (( u8paddr << 4 ));
	if ( TWIGetStatus() != 0x28 )
		return ERROR;
	// send start
	TWIStart();
	if ( TWIGetStatus() != 0x10 )
		return ERROR;
	// select devise and send read bit
	TWIWrite ((( EEREAD ) | ( u8paddr >> 3 )) | 1 );
	if ( TWIGetStatus() != 0x40 )
		return ERROR;
	for ( i = 0; i < 15; i++ ){
		*u8data++ = TWIReadACK();
			if ( TWIGetStatus() != 0x50 )
				return ERROR;
	}
	*u8data = TWIReadNACK();
	if ( TWIGetStatus() != 0x58 )
		return ERROR;
	TWIStop();
	return SUCCESS;
}
*/

// -----------------------------------------------------------------------------

const unsigned char batman[] PROGMEM= 
{ 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf8, 
	0xf8, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 
	0xff, 0xe7, 0x83, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0xc0, 0xfe, 0xfc, 0xf8, 0xf8, 0xfc, 0xfe, 0xc0, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x83, 
	0xe7, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 
	0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xe0, 0xe0, 0xc0, 0xc0, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 
	0x70, 0x78, 0x3c, 0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 
	0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
	0xfe, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfe, 
	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 
	0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3e, 0x3c, 0x78, 0x70, 
	0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0f, 
	0x3f, 0x7f, 0x3f, 0x3f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 0x0f, 
	0x0f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x7f, 0x3f, 0x3f, 0x1f, 0x1f, 0x1f, 0x0f, 0x0f, 0x0f, 
	0x0f, 0x1f, 0x1f, 0x1f, 0x3f, 0x3f, 0x7f, 0x3f, 0x0f, 0x03, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x03, 0x07, 0x0f, 0x3f, 0xff, 0xff, 0x3f, 
	0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00
	};
	
int main(void)
{	
	uint8_t test = 22;
	char string[30] = " ";
	
	/* Backlight pin PL3, set as output, set high for 100% output */
	DDRB |= (1<<PB2);
	PORTB |= (1<<PB2);
	//PORTB &= ~(1<<PB2);
	
	DDRC &= ~(1<<PC0); //Eingang Hallsensor
	PORTC |= (1<<PC0);	//Pullup Hallsensor einschalten
	
	DDRC |=(1<<PC1); 	//Eingang Hallsensor
	PORTC |= (1<<PC1);	//Pullup Hallsensor einschalten
	
	
	DDRD &= ~((1<<PD6) | (1<<PD2) | (1<<PD5)); 	//Taster 1-3
	PORTD |= ((1<<PD6) | (1<<PD2) | (1<<PD5)); 	//PUllups fÃ¼r Taster einschalten
	
	DDRD &= ~(1<<PD4); //T0 Counter Input
	TCCR0B |= (1<<CS02) | (1<<CS01) | (1<<CS00);//Counter 0 enabled clock on rising edge
	
	//Timer 1 Configuration
	OCR1A = 0x009C;	//OCR1A = 0x3D08;==1sec
	
    TCCR1B |= (1 << WGM12);
    // Mode 4, CTC on OCR1A

    TIMSK1 |= (1 << OCIE1A);
    //Set interrupt on compare match

    TCCR1B |= (1 << CS12) | (1 << CS10);
    // set prescaler to 1024 and start the timer

    sei();
    // enable interrupts
	
	setup();
	
	glcd_clear();
	glcd_write();
	
	min = 1;
	
	
	// eeprom
	TWIInit();
	EEWriteByte(50,80);
	delay_ms(500);
	test = EEReadByte(50);
	// Display
	glcd_tiny_set_font(Font5x7,5,7,32,127);
	glcd_clear_buffer();
	sprintf(string,"%d", test);
	glcd_draw_string_xy(0,0,string);
	glcd_write();
	
	/*
	while(1) 
	{
		switch(8)
		{
			case 1:	glcd_test_circles();
					break;
			case 2:	glcd_test_counter_and_graph();
					break;
			case 3:	glcd_test_text_up_down();
					break;
			case 4:	glcd_test_tiny_text();
					break;
			case 5:	glcd_test_hello_world();
					break;
			case 6:	glcd_test_rectangles();
					break;
			case 7:	glcd_test_scrolling_graph();
					break;
			case 8: glcd_draw_bitmap(batman);
					glcd_write();
					break;
		}//end of switch
	}//End of while
	*/
	return 0;
}//end of main
